# 時間複雜度

在寫程式的時候，有時會碰到`TLE`的情況發生，明明做法是對的，卻永遠拿不到`AC` ，因為我們沒有考慮到整筆程式的效率，也就是複雜度方面的考量。

### 複雜度是什麼

複雜度分為時間（Time）與空間（Space）兩種，是用來評估一筆程式執行量能與輸入量關係的一種函式，通常較低複雜度的算法在輸入量變化時，需要的時間或空間成長速度較慢，也就是輸入資料很多時可以用較少時間或較少記憶體來完成，因此複雜度愈低的演算法會被視為較佳的算法，而時間與空間相比之下，時間複雜度的重要性又遠遠大於空間複雜度，在競技程式的題目中所要求的限制或一些優化技巧大多也是針對時間複雜度，因此後面所述的複雜度及例子也以時間複雜度為主。

### 複雜度定義及符號

一筆程式的複雜度可以用函式 $f(x)$ 表示。當一個函式 $g(x)$ 滿足 $f(x)=O(g(x))\ as \ x\to \infty$ 時，代表存在正常數 $c$ 和 $x_0$ ，使得 $0\le |f(x)|\le c|g(x)|\ \forall\ x>x_0$ 。簡單來說，就是在輸入量很大時， $g(x)$ 的執行效率不會比 $f(x)$ 差。這個定義也被稱為漸進上界（Asymptotic Upper Bound）。

在分析上會遵守以下幾個原則：
1. 用最小的上界，也就是符合條件且成長速度盡可能地慢的函數
2. 忽略所有常數
3. 只看成長速度最快的項
舉例來說，有一函數 $f(x)=3x^2+6x+5$，其 $g(x)$ 會被視為 $x^2$ ，不是 $x^3$ 、 $3x^2$ 、 $x^2+x$ 。此外在評估上有些函數實際執行速度和輸入資料本身的值也有關係，在計算複雜度時需要考慮三種情況：

- 最佳情況 (Best Case)
- 平均情況 (Average Case)
- 最糟情況 (Worst Case)

通常我們會以最糟情況來進行分析。比如在一個長度為 $n$ 的序列中進行插入排序法，最好的情況是陣列原本就排好的情況，只需要 $O(n)$ 就可以解決，但最糟的情況會跑到 $O(n^2)$，這時我們需要以後者來估計(除非最壞情況的case非常少、幾乎不可能出現，例如Quick Sort的Worst Case會跑到 $O(n^2)$，但我們通常以 $O(n\log n)$ 來算)。

### 常見複雜度類型

| O-notation | 名稱 | example |
| ---------- | ---- | ------- |
| $O(1)$ | 常數 | 基本運算、輸出輸入 |
| $O(\log n)$ | 對數 | 二分搜 |
| $O(n)$ | 線性 | 遍歷陣列 |
| $O(n\log n)$ | 線性對數 | 快速排序(Quick Sort) |
| $O(n^2)$ | 平方 | 氣泡排序、插入排序 |

### 例子

以下是幾個不同複雜度的程式碼範例：

- $O(1)$

```cpp
int add(int a, int b) {
    return a + b;
}
```

以標準輸出輸入以及基本運算來說，不管資料量有多大(扣除溢位情況)，執行次數都一樣，因此皆屬於常數時間。

- $O(n)$

```cpp
int sum(vector<int>& arr) {
    int total = 0;
    for(int i = 0; i < arr.size(); i++) {
        total += arr[i];
    }
    return total;
}
```

在遍歷陣列的時候，一定是整個陣列從頭到尾掃過一次，因此執行次數一定與陣列大小成正比，屬於線性時間。

- $O(\log n)$

```cpp
int binarySearch(vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;
    
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(arr[mid] == target) return mid;
        if(arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

在二分搜的過程中，最佳情況是一次就找到，而最壞情況則是 $\lceil \log_2 n\rceil$ (其中 $\lceil\ \rceil$ 為上高斯符號)，因此忽略常數後以 $O(\log n)$ 來表示。

- $O(n^2)$

```cpp
void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    for(int i = 0; i < n-1; i++) {
        for(int j = 0; j < n-i-1; j++) {
            if(arr[j] > arr[j+1]) {
                swap(arr[j], arr[j+1]);
            }
        }
    }
}
```

遍歷二維陣列的時候，或是氣泡排序、插入排序的worst case，皆為在一個長 $n$ 的陣列中跑 $n$ 次，因此很直觀的是平方時間。

- $O(n \log n)$

```cpp
void mergeSort(vector<int>& arr, int left, int right) {
    if(left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}
```

在合併排序中，因為使用分治的方法，可將排序壓在線性對數時間(其概念與樹狀結構有關)。

以上這些例子展示了不同複雜度的實際應用。要注意包含更多的迴圈或遞迴結構的程式碼，時間複雜度通常會愈高。

### 時間複雜度與時間的換算

以C++為例，1秒內大約可執行 $10^8$ 次基本運算。因此，當使用線性時間複雜度 $O(n)$ 的演算法時，處理 $10^7$ 筆資料是安全的。而對於平方時間複雜度 $O(n^2)$ 的演算法，由於運算次數會是輸入資料量的平方，因此最多只能處理約 $3000$ ~ $4000$ 筆資料（因為 $4000^2 ≈ 1.6×10^7$ ）。所以當題目的輸入範圍較大時，我們需要尋找更有效率的演算法來降低時間複雜度。
